# 应用安全原理概览

## Dex加固
#### 目的

避免通过反编译的方式查看源码，因为只要看得到源码，无论怎么混淆代码，只要是比较资深的工程师，都能够了解整个代码的调用流程，因此需要对源码进行加密从而防止反编译的攻击

#### 原理

通过对源apk的dex文件加密后，再通过加入新的可运行代码，重新打包成一个新的apk，从而使得源码逻辑不会被第三方获取

#### 加壳流程

* 1.生成执行的源dex；
* 2.对源dex进行加密，生成加密后的dex；
* 3.新建项目专门对dex进行脱壳，并且把加密的dex一同打包进同一apk，最终这个apk就行应用使用的apk

#### 脱壳流程

应用执行，执行的Application类的attachBaseContext方法，在这个方法中对加密dex进行解密，并且通过hook系统classloader的方式，最终运行这个已解密的dex文件，从而达到最终的防止反编译的效果

#### 问题
* 1.这个方法的关键的一步，通过hook系统的classloader的方式最终执行目标dex文件，是一个简化的插件运行方式，完全可以通过目前的插件化方案增加加密功能，即可完成加固
* 2.性能问题，加解密是需要耗时的，因此加壳后的应用会存在首次调用性能问题
* 3.解密的dex文件放置的问题，如果解密后的dex保存在本地，那么同样可以轻松被人获取，边解密边执行似乎是不太可行的，我的想法是可以考虑对解密后的路径随机生成并且进行隐藏，使得dex获取更困难，但是当整个系统都被调试、或者是读取内存的方式，路径同样可以获取到
* 4.兼容问题，很多安全的内容是有冲突的，例如刘俊的加密插件功能则不适用，加密插件需要在编译的时候就确定dex文件，对于RePlugin之类的插件方案也一样，因为需要hook系统classloader，因此也会有冲突

## SO加固

同Dex加固的方法基本相同，只是对应的是C的代码，并且对应的是系统级别的修改（暂时不知道怎么hook系统的C相关的loader）。同样是先生成源so，然后连同脱壳代码打包成新的so，并且在执行的时候，解密so并执行，因此整个架构都是类似的，但是由于so的加载涉及C以及系统更为底层的内容，因此复杂度更高，难度更大，兼容性似乎也是很大的问题，因此以本人的技术深度，估计想要做个demo都不行，后续有机会再深入研究

## 代码虚拟化VM

通过创建一个自己定义的虚拟机，然后执行自己定义的指令，从而达到隐藏流程的做法，防止dump内存信息动态获取流程。难度感觉也不低。

## 反调试

通过检测各种调试时会有的内容，包括adb接口，系统某些文件，某些标志之类的来检测是否处于调试中，自行结束应用，达到无法调试的目的
